#include <ruby.h>
#include <pcg_variants.h>
#include <stdbool.h>
#include <stdint.h>

#include "entropy.h"
#include "rb_constants.h"
#include "pcg_seed.h"

static VALUE pcg_new_seed_bytestr(unsigned long seed_size);
static VALUE pcg_raw_seed_bytestr(size_t size);

/*
 * Returns a n-byte integer that stores the seed value used to seed the 
 * initial state and sequence for the PCG generator.
 * If no parameters are supplied it default to a 128-bit seed size
 * 
 * @param size Number of bytes (EVEN!) that the generated seed must contain.
 *  Defaults to 16 Bytes (uint8_t) = 128 bits
 *
 * @raise ArgumentError if size is not even
 */ 
VALUE
pcg_func_new_seed(int argc, VALUE *argv, VALUE self)
{
    VALUE seed_size;
    unsigned long n;
    
    if(argc == 0)
    {
        return pcg_new_seed_bytestr(16 * sizeof(uint8_t));
    }
    
    rb_scan_args(argc, argv, "01", &seed_size);
    n = NUM2ULONG(seed_size);
    
    // Only accept even seed sizes since this later needs to be split into
    // two parts!
    if(n % 2 == 1)
    {
        rb_raise(rb_eArgError, "Seed size must be even! Found %lu", n);
    }
    return pcg_new_seed_bytestr(n * sizeof(uint8_t));
}

/*
 * Generates a random seed string represented as a sequence of bytes 
 *
 * @param size Size of the bytestring to generate
 */
VALUE
pcg_func_raw_seed(VALUE self, VALUE byte_size)
{
    unsigned long n = NUM2ULONG(byte_size);
    if(n == 0)
    {
        return rb_str_new2("\0");
    }
    return pcg_raw_seed_bytestr(n);
}

/*
 * Generates a sequence of random bytes using device entropy
 * or a fallback mechanism based on pcg32_random_r
 */
bool 
pcg_func_entropy_getbytes(void *dest, size_t size)
{
    // Get random bytes from /dev/random or a fallback source
    if(!entropy_getbytes(dest, size))
    {
        fallback_entropy_getbytes(dest, size);
        return true;
    }
    return true;
}

/*
 * Internal - gets `size` number of random bytes from a platform source
 * and returns those as a ruby string
 */
static VALUE
pcg_raw_seed_bytestr(size_t size)
{
    VALUE result;
    char *bytestr = (char *) malloc(size + 1);
    if(bytestr == NULL)
    {
        rb_raise(rb_eNoMemError, 
            "Could not malloc enough space for %lu-byte seed!", size);
    }
    memset(bytestr, 0, size + 1);
    pcg_func_entropy_getbytes((void *)bytestr, size);
    
    result = rb_str_new2(bytestr);
    free(bytestr);
    
    return result;
}

/*
 * Internal - Two random integers are sourced from /dev/random or a fallback
 * source 
 * Seed generated by manipulating a 16byte string & unpacking it to Q*
 */
static VALUE
pcg_new_seed_bytestr(unsigned long seed_size)
{
    VALUE result;
    uint8_t *bytes = (uint8_t *) malloc(seed_size * sizeof(uint8_t));
    unsigned long *buf = (unsigned long *) malloc(seed_size * sizeof(unsigned long));
    
    if(bytes == NULL || buf == NULL)
    {
        rb_raise(rb_eNoMemError, "Could not malloc enough memory!");
    }
    
    memset(bytes, 0, seed_size);
    
    if(!pcg_func_entropy_getbytes((void *)bytes, seed_size))
    {
        rb_raise(rb_eRuntimeError, "Unable to generate seed!");
    }
    
    // Populate an array of longs to feed to rb_big_unpack()
    for(int i = 0; i < seed_size; ++i)
    {
        buf[i] = (unsigned long) bytes[i];
    }
    
    // Inspired from ruby's very own random.c
    // see: http://rxr.whitequark.org/mri/source/random.c#493
    // Also: http://rxr.whitequark.org/mri/source/random.c#443
    result = rb_big_unpack(buf, seed_size);
    
    free(bytes);
    free(buf);
    
    return result;
}
