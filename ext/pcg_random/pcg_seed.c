#include <ruby.h>

#include <pcg_variants.h>

#include "entropy.h"
#include "rb_constants.h"
#include "pcg_seed.h"

/* Functions local to this source file */
static VALUE pcg_new_seed_bigmul(void);
static VALUE pcg_new_seed_bytestr(void);

/*
 * call-seq: pcg_random.new_seed -> aBignum
 * 
 * Returns a 128-bit big-integer that stores the seed value used to seed the 
 * initial state and sequence for the PCG generator.
 * 
 * Two 64 bit uints are generated and merged and returned as:
 * (2 ** 64) * MSB + LSB
 */ 
VALUE
pcg_func_new_seed(void)
{
    return pcg_new_seed_bytestr();
}

/*
 * Two random integers are sourced from /dev/random or a fallback technique
 * Seed generated by generating and merging 2 uint64_t's as:
 * (2 ** 64) * MSB + LSB
 * 
 * @see pcg_new_seed_bytestr() for alternative techniques
 */
static VALUE
pcg_new_seed_bigmul(void)
{
    uint64_t seeds[2];
    VALUE low, high, TWO_POWER_64;

    /* Get random bytes from /dev/ranom or a fallback source */
    if(!entropy_getbytes((void*)seeds, sizeof(seeds)))
    {
        fallback_entropy_getbytes((void*)seeds, sizeof(seeds));
    }

    TWO_POWER_64 = rb_big_plus(rb_uint2big(UINT64_MAX), pcg_rb_one);
    low  = rb_uint2big(seeds[1]);
    high = rb_big_mul(rb_uint2big(seeds[0]), TWO_POWER_64);
    
    return rb_big_plus(high, low);
}


/*
 * Two random integers are sourced from /dev/random or a fallback technique
 * Seed generated by manipulating a 16byte string & unpacking it to Q*
 * 
 * @see pcg_new_seed_bigmul() for alternative techniques
 */
static VALUE
pcg_new_seed_bytestr(void)
{
    uint64_t seeds[2];
    char *seed_bytes = (char *) malloc(sizeof(seeds) + 1);
    VALUE seed_bytes_str, result_ary;

    /* Get random bytes from /dev/ranom or a fallback source */
    if(!entropy_getbytes((void*)seeds, sizeof(seeds)))
    {
        fallback_entropy_getbytes((void*)seeds, sizeof(seeds));
    }
    
    memset(seed_bytes, 0, sizeof(seeds) + 1);
    memcpy(seed_bytes, seeds, sizeof(seeds));
    
    seed_bytes_str = rb_str_new2(seed_bytes);
    
    /* 
     * String#unpack via rb_funcall
     * because pack.c/pack_unpack is not accessible directly (??)
     */
    result_ary = rb_funcall(seed_bytes_str, rb_intern("unpack"), 1, 
                            rb_str_new2("Q*\0"));
    
    /* Return element 0 */
    return rb_ary_entry(result_ary, 0);
}