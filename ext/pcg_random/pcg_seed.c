#include <ruby.h>
#include <pcg_variants.h>
#include <stdbool.h>

#include "entropy.h"
#include "rb_constants.h"
#include "pcg_seed.h"

static VALUE pcg_new_seed_bytestr(unsigned long seed_size);
static VALUE pcg_raw_seed_bytestr(size_t size);
static VALUE pcg_rb_unpack_str_uint(VALUE str);

/*
 * Returns a n-bit integer that stores the seed value used to seed the 
 * initial state and sequence for the PCG generator.
 * If no parameters are supplied it default to a 128-bit seed size
 * 
 * @param size Number of bytes (EVEN!) that the generated seed must contain.
 *  Defaults to 16 Bytes = 128 bits
 *
 * @raise ArgumentError if size is not even
 */ 
VALUE
pcg_func_new_seed(int argc, VALUE *argv, VALUE self)
{
    VALUE seed_size;
    unsigned long n;
    
    if(argc == 0)
    {
        return pcg_new_seed_bytestr(2 * sizeof(uint64_t));
    }
    
    rb_scan_args(argc, argv, "01", &seed_size);
    n = NUM2ULONG(seed_size);
    
    // Only accept even seed sizes since this later needs to be split into
    // two parts!
    if(n % 2 == 1)
    {
        rb_raise(rb_eArgError, "Seed size must be even! Found %lu", n);
    }
    return pcg_new_seed_bytestr(n * sizeof(char));
}

/*
 * Generates a random seed string represented as a sequence of bytes 
 *
 * @param size Size of the bytestring to generate
 */
VALUE
pcg_func_raw_seed(VALUE self, VALUE byte_size)
{
    unsigned long n = NUM2ULONG(byte_size);
    if(n == 0)
    {
        return rb_str_new2("\0");
    }
    return pcg_raw_seed_bytestr(n);
}

/*
 * Generates a sequence of random bytes using device entropy
 * or a fallback mechanism based on pcg32_random_r
 */
bool 
pcg_func_entropy_getbytes(void *dest, size_t size)
{
    // Get random bytes from /dev/random or a fallback source
    return entropy_getbytes(dest, size);
}

/*
 * Internal - Unpacks a string `str` wuth String#unpack
 */
static VALUE
pcg_rb_unpack_str_uint(VALUE str)
{
    VALUE ary, result, current, base;
    unsigned long len;
    
    // This would be an array of 8 bit fixnums, effectively representing it in
    // base-256
    ary = rb_funcall(str, rb_intern("unpack"), 1, rb_str_new2("C*\0"));
    len = RARRAY_LEN(ary);
    
    base = INT2FIX(256);
    result = pcg_rb_zero;
    
    // First entry in array corresponds to highest significance
    for(int i = 0; i < len; ++i)
    {
        current = rb_ary_entry(ary, i);
        // Maybe optimize the below code based on on TYPE(result) later ?
        // Currently this doesnt utilize the C-API a effectively
        result = rb_funcall(result, pcg_rb_plus, 1, current);
        result = rb_funcall(result, pcg_rb_mul, 1 , base);
    }
    
    return result;
}

/*
 * Internal - gets `size` number of random bytes from a platform source
 * and returns those as a ruby string
 */
static VALUE
pcg_raw_seed_bytestr(size_t size)
{
    char *bytestr = (char *) malloc(size + 1);
    VALUE result;
    
    memset(bytestr, 0, size + 1);
    pcg_func_entropy_getbytes((void *)bytestr, size);
    
    result = rb_str_new2(bytestr);
    free(bytestr);
    
    return result;
}

/*
 * Internal - Two random integers are sourced from /dev/random or a fallback
 * source 
 * Seed generated by manipulating a 16byte string & unpacking it to Q*
 */
static VALUE
pcg_new_seed_bytestr(unsigned long seed_size)
{
    VALUE seed_bytes_str;
    seed_bytes_str = pcg_raw_seed_bytestr(seed_size);
    return pcg_rb_unpack_str_uint(seed_bytes_str);
}

