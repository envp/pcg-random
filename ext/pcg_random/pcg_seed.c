#include <ruby.h>
#include <pcg_variants.h>
#include <stdbool.h>
#include <inttypes.h>

#include "entropy.h"
#include "rb_constants.h"
#include "pcg_seed.h"

static VALUE pcg_new_seed_bytestr(unsigned long seed_size);
static VALUE pcg_raw_seed_bytestr(size_t size);

/*
 * Returns a n-bit integer that stores the seed value used to seed the 
 * initial state and sequence for the PCG generator.
 * If no parameters are supplied it default to a 128-bit seed size
 * 
 * @param size Number of bytes (EVEN!) that the generated seed must contain.
 *  Defaults to 16 Bytes (uint8_t) = 128 bits
 *
 * @raise ArgumentError if size is not even
 */ 
VALUE
pcg_func_new_seed(int argc, VALUE *argv, VALUE self)
{
    VALUE seed_size;
    unsigned long n;
    
    if(argc == 0)
    {
        return pcg_new_seed_bytestr(16 * sizeof(uint8_t));
    }
    
    rb_scan_args(argc, argv, "01", &seed_size);
    n = NUM2ULONG(seed_size);
    
    // Only accept even seed sizes since this later needs to be split into
    // two parts!
    if(n % 2 == 1)
    {
        rb_raise(rb_eArgError, "Seed size must be even! Found %lu", n);
    }
    return pcg_new_seed_bytestr(n * sizeof(char));
}

/*
 * Generates a random seed string represented as a sequence of bytes 
 *
 * @param size Size of the bytestring to generate
 */
VALUE
pcg_func_raw_seed(VALUE self, VALUE byte_size)
{
    unsigned long n = NUM2ULONG(byte_size);
    if(n == 0)
    {
        return rb_str_new2("\0");
    }
    return pcg_raw_seed_bytestr(n);
}

/*
 * Generates a sequence of random bytes using device entropy
 * or a fallback mechanism based on pcg32_random_r
 */
bool 
pcg_func_entropy_getbytes(void *dest, size_t size)
{
    // Get random bytes from /dev/random or a fallback source
    if(!entropy_getbytes(dest, size))
    {
        fallback_entropy_getbytes(dest, size);
        return true;
    }
    return false;
}

/*
 * Internal - gets `size` number of random bytes from a platform source
 * and returns those as a ruby string
 */
static VALUE
pcg_raw_seed_bytestr(size_t size)
{
    VALUE result;
    char *bytestr = (char *) malloc(size + 1);
    if(bytestr == NULL)
    {
        rb_raise(rb_eNoMemError, 
            "Could not malloc enough space for %lu-byte seed!", size);
    }
    memset(bytestr, 0, size + 1);
    pcg_func_entropy_getbytes((void *)bytestr, size);
    
    result = rb_str_new2(bytestr);
    free(bytestr);
    
    return result;
}

/*
 * Internal - Two random integers are sourced from /dev/random or a fallback
 * source 
 * Seed generated by manipulating a 16byte string & unpacking it to Q*
 */
static VALUE
pcg_new_seed_bytestr(unsigned long seed_size)
{
    VALUE result, base;
    unsigned long x;
    
    uint8_t *bytes = (uint8_t *) malloc(seed_size);
    
    if(bytes == NULL)
    {
        rb_raise(rb_eNoMemError, 
            "Could not malloc enough memory for %lu byte seed!", seed_size);
    }
    
    memset(bytes, 0, seed_size);
    
    if(!pcg_func_entropy_getbytes((void *)bytes, seed_size))
    {
        rb_raise(rb_eRuntimeError, "Unable to generate seed!");
    }
    
    /*
     * Unpacking array of 8-bit uints into a Fixnum / Bignum
     */
    
    base = INT2FIX(256);
    result = pcg_rb_zero;
    
    /*
     * First entry in array corresponds to highest significance
     *
     * The below loop is effectively converting a base 256 number to base 10
     * given 8 1-byte unsigned numbers
     */
    for(int i = 0; i < seed_size; ++i)
    {
        // result = ((a0*K + a1)*K + a2)*K + ... )
        
        switch(TYPE(result))
        {
            case T_FIXNUM:
                x = NUM2ULONG(result);
                result = ULONG2NUM(x + bytes[i]);
                break;
            case T_BIGNUM:
                result = rb_big_plus(result, UINT2NUM(bytes[i]));
                break;
            default:
                rb_num_coerce_bin(result, UINT2NUM(bytes[i]), '+');
        }
        
        // a_n1 = k * (a_n1)
        switch(TYPE(result))
        {
            case T_FIXNUM:
                x = NUM2ULONG(result);
                result = ULONG2NUM(x * 256u);
                break;
            case T_BIGNUM:
                result = rb_big_mul(result, base);
                break;
            default:
                rb_num_coerce_bin(result, base, '*');
        }
    }
    free(bytes);
    return result;
}

